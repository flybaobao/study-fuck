## import 放到页面头部 拥有声明作用，可以变量提升
## 模块加载  打包工具
 基于commonJs形式来书写  对amd/cmd都支持
## 下载 webpack
```
npm init -y
npm install webpack -g
```
> 安装webpack或者less 最好不要全局安装，否则会导致webpack、版本差异
> 在package.json 文件中配置一个脚本，这个脚本的命令是webpack  会去当前的 node_modules下bin对应的webpack名字让其去执行，执行的就是bin/webpack.js   webpack.js 需要当前的目录下要有一个名字叫webpack.config.js的文件

```
// webpack 必须采用common.js写法
let path = require('path'); 
// 这是一个 一个专门处理路径的，以当前路径解析出一个相对路径
console.log(path.resolve(',/dist'));

module.exports = {
 entry: '',// 打包的入口文件，webpack会自动的查找相关的依赖进行打包
 output: {
  filename: 'bundle.js', // 打包后的名字
  path: path.resolve('./dist') // 必须是个绝对路径
 },
 // 模块解析规则
 // -js 匹配所有的js'   用  babel-loader 转译  排除掉  node_modules
 module: {
  
 }
}
```

4.4模块的缓存

第一次加载某个模块时，Node会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的module.exports属性。


require('./example.js');require('./example.js').message = "hello";require('./example.js').message// "hello"

上面代码中，连续三次使用require命令，加载同一个模块。第二次加载的时候，为输出的对象添加了一个message属性。但是第三次加载的时候，这个message属性依然存在，这就证明require命令并没有重新加载模块文件，而是输出了缓存。
如果想要多次执行某个模块，可以让该模块输出一个函数，然后每次require这个模块的时候，重新执行一下输出的函数。
所有缓存的模块保存在require.cache之中，如果想删除模块的缓存，可以像下面这样写。



// 删除指定模块的缓存delete require.cache[moduleName];// 删除所有模块的缓存
```
Object.keys(require.cache).forEach(function(key) {  delete require.cache[key];
```
})
[commonJS](http://www.php.cn/js-tutorial-387885.html)
